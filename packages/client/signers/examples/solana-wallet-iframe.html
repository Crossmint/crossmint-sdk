<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Solana Wallet iFrame</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h1 {
      margin-top: 0;
      color: #3a3a3a;
    }
    .status {
      margin-top: 20px;
      padding: 10px;
      border-radius: 4px;
      background-color: #f0f0f0;
      font-family: monospace;
      max-height: 200px;
      overflow-y: auto;
    }
    .connected {
      color: green;
      font-weight: bold;
    }
    .disconnected {
      color: #999;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Solana Wallet iFrame</h1>
    <p>This iframe contains a mock Solana wallet implementation that communicates with the parent window.</p>
    <p>Status: <span id="connection-status" class="disconnected">Waiting for connection...</span></p>
    <div class="status" id="log-output"></div>
  </div>

  <script>
    // This would typically be imported from your bundled application
    // For demo purposes, we're defining a mock implementation
    
    class MockSolanaWallet {
      constructor() {
        this.status = 'disconnected';
        this._keyPair = this._generateMockKeyPair();
        this.log('Wallet initialized with mock keypair');
      }

      async connect() {
        this.log('Connecting wallet...');
        await this._delay(500); // Simulate network delay
        this.status = 'connected';
        const address = this._keyPair.publicKey;
        document.getElementById('connection-status').textContent = `Connected (${address.substring(0, 8)}...)`;
        document.getElementById('connection-status').className = 'connected';
        this.log(`Connected with address: ${address}`);
        return address;
      }

      async signMessage(messageBytes) {
        this._checkConnection();
        this.log(`Signing message: ${new TextDecoder().decode(messageBytes)}`);
        await this._delay(1000); // Simulate signing delay
        
        // Create a mock signature (in real implementation, this would use the keypair to sign)
        const mockSignature = new Uint8Array(64).fill(1);
        this.log('Message signed successfully');
        return mockSignature;
      }

      async signTransaction(transactionBytes) {
        this._checkConnection();
        this.log('Signing transaction...');
        await this._delay(1000); // Simulate signing delay
        
        // In a real implementation, this would deserialize, sign, and serialize the transaction
        // For demo, we'll just return the same bytes
        this.log('Transaction signed successfully');
        return transactionBytes;
      }

      async sendTransaction(transactionBytes) {
        this._checkConnection();
        this.log('Sending transaction...');
        await this._delay(1500); // Simulate network delay
        
        // Generate a mock transaction signature
        const txSignature = Array.from({ length: 32 }, () => 
          Math.floor(Math.random() * 16).toString(16)
        ).join('');
        
        this.log(`Transaction sent with signature: ${txSignature}`);
        return txSignature;
      }

      // Helper methods
      _checkConnection() {
        if (this.status !== 'connected') {
          throw new Error('Wallet not connected');
        }
      }

      _generateMockKeyPair() {
        return {
          publicKey: 'soL' + Array.from({ length: 40 }, () => 
            Math.floor(Math.random() * 16).toString(16)
          ).join('')
        };
      }

      _delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      log(message) {
        console.log(message);
        const logOutput = document.getElementById('log-output');
        const logEntry = document.createElement('div');
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logOutput.appendChild(logEntry);
        logOutput.scrollTop = logOutput.scrollHeight;
      }
    }

    // When the SDK is actually imported
    class SolanaIFrameContentHandler {
      constructor(wallet) {
        this.wallet = wallet;
        this.log('SolanaIFrameContentHandler initialized');
      }

      async init() {
        this.log('Setting up communication with parent window...');
        // In a real implementation, this would connect to the parent window
        // using HandshakeChild from @crossmint/client-sdk-window
        this.log('Handshake with parent window successful');
        this.setupMockEventListeners();
      }

      setupMockEventListeners() {
        this.log('Waiting for requests from parent window...');
        // In a real implementation, this would set up event listeners
        // This is just for demonstration
      }

      log(message) {
        const wallet = this.wallet;
        if (wallet && typeof wallet.log === 'function') {
          wallet.log(message);
        } else {
          console.log(message);
        }
      }
    }

    // Initialize the mock wallet and iframe handler
    document.addEventListener('DOMContentLoaded', () => {
      const wallet = new MockSolanaWallet();
      const handler = new SolanaIFrameContentHandler(wallet);
      handler.init().catch(err => {
        console.error('Failed to initialize handler:', err);
      });

      // For demo purposes only - expose wallet to parent window
      // In a real implementation, communication would happen through proper channels
      window.mockWallet = wallet;
    });
  </script>
</body>
</html> 