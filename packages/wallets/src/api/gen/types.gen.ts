// This file is auto-generated by @hey-api/openapi-ts

/**
 * Input schema for creating a new signature. The parameters vary based on the signature type.
 */
export type CreateSignatureRequestDto = {
    type: 'evm-message';
    /**
     * Parameters for an EVM signature
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
        /**
         * The locator for the signer who will submit this signature. Defaults to the wallet's admin signer.
         */
        signer?: string;
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
    };
} | {
    type: 'solana-message';
    /**
     * Parameters for a Solana signature
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
    };
} | {
    type: 'evm-typed-data';
    /**
     * Parameters for an EVM typed data signature
     */
    params: {
        typedData: {
            domain: {
                name: string;
                version: string;
                chainId: number;
                /**
                 * An EVM address string
                 */
                verifyingContract: string;
                salt?: string;
            };
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            primaryType: string;
            message: {};
        };
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
        /**
         * The locator for the signer who will approve this signature
         */
        signer?: string;
        /**
         * Whether the signature corresponds to the smart wallet or to the signer. If true, the signature will be wrapped with ERC6492.
         */
        isSmartWalletSignature?: boolean;
    };
};

export type CreateSignerInputDto = {
    /**
     * The locator of the delegated signer
     */
    signer: string;
    /**
     * The chain where the signer will be registered
     */
    chain: 'base' | 'polygon' | 'optimism' | 'arbitrum' | 'mode' | 'base-sepolia' | 'polygon-amoy' | 'optimism-sepolia' | 'arbitrum-sepolia' | 'mode-sepolia' | 'story-testnet';
    /**
     * The expiry date of the signer in milliseconds since UNIX epoch
     */
    expiresAt?: number;
    /**
     * The permissions of the signer following ERC-7715
     */
    permissions?: Array<{
        type: 'native-token-transfer';
        data: {
            allowance: string;
        };
    } | {
        type: 'erc20-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            allowance: string;
        };
    } | {
        type: 'erc721-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs that can be transferred
             */
            tokenIds: Array<string>;
        };
    } | {
        type: 'erc1155-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs and allowances that can be transferred
             */
            allowances: {
                [key: string]: string;
            };
        };
    } | {
        type: 'gas-limit';
        data: {
            limit: string;
            enforcePaymaster?: boolean;
            allowedPaymaster?: string;
        };
    } | {
        type: 'call-limit';
        data: {
            count: number;
        };
    } | {
        type: 'rate-limit';
        data: {
            count: number;
            /**
             * Time window in seconds
             */
            interval: number;
        };
    }>;
} | {
    /**
     * The locator of the delegated signer
     */
    signer: string;
};

/**
 * Input schema for creating a new transaction. The parameters vary based on the wallet type (EVM vs Solana).
 */
export type CreateTransactionDto = {
    /**
     * Wallet type specific transaction parameters
     */
    params: {
        /**
         * Transaction data to execute
         */
        calls: Array<{
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
            /**
             * The amount of native token to send in wei
             */
            value?: string;
        } | {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The amount of native token to send in wei
             */
            value: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        }>;
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'base' | 'polygon' | 'optimism' | 'arbitrum' | 'mode' | 'base-sepolia' | 'polygon-amoy' | 'optimism-sepolia' | 'arbitrum-sepolia' | 'mode-sepolia' | 'story-testnet';
        /**
         * The locator for the signer who will submit this transaction
         */
        signer?: string;
    } | {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
    } | {
        /**
         * The transaction call to execute
         */
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
        };
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
    } | {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
        /**
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
    };
};

export type CreateWalletDto = {
    type: 'evm-smart-wallet';
    config?: {
        adminSigner: {
            /**
             * Identifier for EVM keypair signer type
             */
            type: 'evm-keypair';
            /**
             * The Ethereum address of the external signer
             */
            address: string;
        } | {
            /**
             * Identifier for EVM Fireblocks custodial signer type
             */
            type: 'evm-fireblocks-custodial';
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'evm-passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
        };
        /**
         * The unique wallet seed. By default, the seed is randomly generated.
         */
        creationSeed?: string;
    };
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'solana-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'solana-smart-wallet';
    config?: {
        adminSigner?: {
            /**
             * Identifier for Solana keypair signer type
             */
            type: 'solana-keypair';
            /**
             * The Solana public key (base58 encoded) of the external signer
             */
            address: string;
        } | {
            /**
             * Identifier for Solana Fireblocks MPC signer type
             */
            type: 'solana-fireblocks-custodial';
        };
    };
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'aptos-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'cardano-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'sui-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'solana-custodial-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'evm-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
};

export type DelegatedSignerDto = {
    /**
     * Specifies the type of EVM signer being used, describing the method of key management and transaction signing. `evm-keypair` indicates a signer using a locally managed keypair, suitable for non-custodial wallets. `evm-fireblocks-custodial` refers to a signer managed by Fireblocks, a custodial service provider.
     */
    type: 'evm-keypair' | 'evm-fireblocks-custodial';
    /**
     * The Ethereum address of the signer
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The expiry date of the signer in ISO 8601 format
     */
    expiresAt?: number;
    /**
     * The permissions of the signer following ERC-7715
     */
    permissions?: Array<{
        type: 'native-token-transfer';
        data: {
            allowance: string;
        };
    } | {
        type: 'erc20-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            allowance: string;
        };
    } | {
        type: 'erc721-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs that can be transferred
             */
            tokenIds: Array<string>;
        };
    } | {
        type: 'erc1155-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs and allowances that can be transferred
             */
            allowances: {
                [key: string]: string;
            };
        };
    } | {
        type: 'gas-limit';
        data: {
            limit: string;
            enforcePaymaster?: boolean;
            allowedPaymaster?: string;
        };
    } | {
        type: 'call-limit';
        data: {
            count: number;
        };
    } | {
        type: 'rate-limit';
        data: {
            count: number;
            /**
             * Time window in seconds
             */
            interval: number;
        };
    }>;
    /**
     * Authorization status for each chain where the chain name is the key and the signature request is the value
     */
    chains?: {
        [key: string]: {
            status: 'success';
        } | {
            status: 'pending' | 'awaiting-approval' | 'failed';
            /**
             * Unique identifier for the signature
             */
            id: string;
            /**
             * Complete approval data including requirements, pending and submitted signatures
             */
            approvals?: {
                /**
                 * List of pending signatures
                 */
                pending: Array<{
                    /**
                     * The locator of the signer that's pending approval
                     */
                    signer: string;
                    /**
                     * The message that needs to be signed
                     */
                    message: string;
                }>;
                /**
                 * Record of all submitted signatures
                 */
                submitted: Array<{
                    /**
                     * The cryptographic signature
                     */
                    signature: string;
                    /**
                     * When the signature was submitted
                     */
                    submittedAt: number;
                    /**
                     * The locator of the signer who submitted this signature
                     */
                    signer: string;
                    /**
                     * The message that was signed
                     */
                    message: string;
                    /**
                     * Additional metadata about the signature submission
                     */
                    metadata?: {
                        deviceInfo?: string;
                        ipAddress?: string;
                        userAgent?: string;
                    };
                }>;
                /**
                 * Number of required approvals for the transaction
                 */
                required?: number;
            };
        };
    };
} | {
    /**
     * Specifies the type of Solana signer being used, describing the method of key management and transaction signing.
     */
    type: 'solana-keypair' | 'solana-fireblocks-custodial';
    /**
     * The Solana address of the signer
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The transaction for the signer
     */
    transaction: {
        /**
         * Solana smart wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string;
                explorerLink?: string;
                simulationLink?: string;
            };
        };
    };
};

/**
 * Parameters required to fund a wallet
 */
export type FundWalletAmountDto = {
    /**
     * The amount of currency to fund the wallet with. Between 1 and 100
     */
    amount: number;
    /**
     * The currency to fund the wallet with
     */
    token: 'ape' | 'eth' | 'matic' | 'pol' | 'sei' | 'chz' | 'avax' | 'xai' | 'fuel' | 'vic' | 'ip' | 'zcx' | 'usdc' | 'usdce' | 'busd' | 'usdxm' | 'weth' | 'degen' | 'brett' | 'toshi' | 'eurc' | 'superverse' | 'bonk' | 'wif' | 'mother' | 'trump' | 'melania' | 'sol' | 'ada' | 'bnb' | 'sui' | 'apt' | 'sfuel';
    /**
     * The chain to fund the wallet with
     */
    chain?: 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'barret-testnet' | 'ethereum-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'sei-atlantic-2-testnet' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'viction-testnet' | 'solana';
};

/**
 * Input schema for sending different types of tokens
 */
export type SendTokenDto = {
    /**
     * Recipient address, email or twitter handle
     */
    recipient: string;
    /**
     * Optional signer locator. Defaults to admin signer
     */
    signer?: string;
    /**
     * A token locator that supports native tokens, fungible tokens, and NFTs across different chains. It can be of the format:
     * - `chain:address[:tokenId]`
     * - `chain:currency`
     * - `chain:address`
     */
    token: string;
    /**
     * Amount of tokens to transfer
     */
    amount?: string;
};

/**
 * Input for submitting one or more approvals
 */
export type SubmitApprovalDto = {
    /**
     * Array of approvals to submit for this transaction
     */
    approvals: {
        /**
         * The locator for the EVM signer
         */
        signer: string;
        /**
         * The EVM cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the EVM signer
         */
        signer: string;
        /**
         * The signature components
         */
        signature: {
            /**
             * R component of the signature as a stringified bigint
             */
            r: string;
            /**
             * S component of the signature as a stringified bigint
             */
            s: string;
        };
        /**
         * WebAuthn signature metadata
         */
        metadata: {
            /**
             * WebAuthn authenticator data as hex string
             */
            authenticatorData: string;
            /**
             * Index of the challenge used
             */
            challengeIndex: number;
            /**
             * WebAuthn client data JSON string
             */
            clientDataJSON: string;
            /**
             * Index of the signature type
             */
            typeIndex: number;
            /**
             * Whether user verification was required
             */
            userVerificationRequired: boolean;
        };
    } | Array<{
        /**
         * The locator for the Solana signer
         */
        signer: string;
        /**
         * The Solana cryptographic signature
         */
        signature: string;
    }>;
};

/**
 * The balances of the wallet
 */
export type WalletBalanceResponseDto = Array<{
    /**
     * The token
     */
    token: 'ape' | 'eth' | 'matic' | 'pol' | 'sei' | 'chz' | 'avax' | 'xai' | 'fuel' | 'vic' | 'ip' | 'zcx' | 'usdc' | 'usdce' | 'busd' | 'usdxm' | 'weth' | 'degen' | 'brett' | 'toshi' | 'eurc' | 'superverse' | 'bonk' | 'wif' | 'mother' | 'trump' | 'melania' | 'sol' | 'ada' | 'bnb' | 'sui' | 'apt' | 'sfuel';
    /**
     * The number of decimals of the token
     */
    decimals: number;
    /**
     * The balance of the wallet in different chains
     */
    balances: {
        [key: string]: string;
    };
}>;

/**
 * List of signatures with their status, signing requirements, and wallet type specific data
 */
export type WalletsV1Alpha2MultipleSignatureResponseDto = {
    signatures: Array<{
        /**
         * Unique identifier for the signature
         */
        id: string;
        /**
         * The type of signature
         */
        type: 'evm-message' | 'solana-message' | 'evm-typed-data' | 'aptos-message' | 'cardano-message' | 'sui-message';
        /**
         * Current status of the signature
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Type-specific signature parameters
         */
        params: {
            /**
             * The message in plain text to sign
             */
            message: string;
            /**
             * The locator for the signer who will submit this signature. Defaults to the wallet's admin signer.
             */
            signer?: string;
            /**
             * The chain on which the signature will be submitted
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
        } | {
            /**
             * The message in plain text to sign
             */
            message: string;
        } | {
            typedData: {
                domain: {
                    name: string;
                    version: string;
                    chainId: number;
                    /**
                     * An EVM address string
                     */
                    verifyingContract: string;
                    salt?: string;
                };
                types: {
                    [key: string]: Array<{
                        name: string;
                        type: string;
                    }>;
                };
                primaryType: string;
                message: {};
            };
            /**
             * The chain on which the signature will be submitted
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
            /**
             * The locator for the signer who will approve this signature
             */
            signer?: string;
            /**
             * Whether the signature corresponds to the smart wallet or to the signer. If true, the signature will be wrapped with ERC6492.
             */
            isSmartWalletSignature?: boolean;
        };
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the signature was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the signature fails
         */
        error?: unknown;
        /**
         * The wallet's output signature of the request
         */
        outputSignature?: string;
    }>;
};

/**
 * Complete signature response including status, signing requirements, and wallet type specific data
 */
export type WalletsV1Alpha2SignatureResponseDto = {
    /**
     * Unique identifier for the signature
     */
    id: string;
    /**
     * The type of signature
     */
    type: 'evm-message' | 'solana-message' | 'evm-typed-data' | 'aptos-message' | 'cardano-message' | 'sui-message';
    /**
     * Current status of the signature
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Type-specific signature parameters
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
        /**
         * The locator for the signer who will submit this signature. Defaults to the wallet's admin signer.
         */
        signer?: string;
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
    } | {
        /**
         * The message in plain text to sign
         */
        message: string;
    } | {
        typedData: {
            domain: {
                name: string;
                version: string;
                chainId: number;
                /**
                 * An EVM address string
                 */
                verifyingContract: string;
                salt?: string;
            };
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            primaryType: string;
            message: {};
        };
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
        /**
         * The locator for the signer who will approve this signature
         */
        signer?: string;
        /**
         * Whether the signature corresponds to the smart wallet or to the signer. If true, the signature will be wrapped with ERC6492.
         */
        isSmartWalletSignature?: boolean;
    };
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the signature was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the signature fails
     */
    error?: unknown;
    /**
     * The wallet's output signature of the request
     */
    outputSignature?: string;
};

/**
 * Complete transaction response including status, signing requirements, and wallet type specific data
 */
export type WalletsV1Alpha2TransactionResponseDto = {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'evm-smart-wallet';
    /**
     * EVM smart wallet transaction parameters
     */
    params: {
        /**
         * Transaction data to execute
         */
        calls: Array<{
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
            /**
             * The amount of native token to send in wei
             */
            value?: string;
        } | {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The amount of native token to send in wei
             */
            value: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        }>;
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'base' | 'polygon' | 'optimism' | 'arbitrum' | 'mode' | 'base-sepolia' | 'polygon-amoy' | 'optimism-sepolia' | 'arbitrum-sepolia' | 'mode-sepolia' | 'story-testnet';
        /**
         * The locator for the signer who will submit this transaction
         */
        signer?: string;
    };
    /**
     * EVM smart wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        userOperation: {
            sender: string;
            nonce: string;
            callData: string;
            callGasLimit: string;
            verificationGasLimit: string;
            preVerificationGas: string;
            maxFeePerGas: string;
            maxPriorityFeePerGas: string;
            paymaster?: string;
            paymasterVerificationGasLimit?: string;
            paymasterData?: string;
            paymasterPostOpGasLimit?: string;
            signature: string;
            factory?: string;
            factoryData?: string;
        };
        userOperationHash: string;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string;
            explorerLink?: string;
            simulationLink?: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'solana-mpc-wallet';
    /**
     * Solana custodial wallet transaction parameters
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
    };
    /**
     * Solana custodial wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string;
            explorerLink?: string;
            simulationLink?: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'evm-mpc-wallet';
    /**
     * EVM MPC wallet transaction parameters
     */
    params: {
        /**
         * The transaction call to execute
         */
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
        };
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
    };
    /**
     * EVM MPC wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        };
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string;
            explorerLink?: string;
            simulationLink?: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'solana-smart-wallet';
    /**
     * Solana smart wallet transaction parameters
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
        /**
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
    };
    /**
     * Solana smart wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string;
            explorerLink?: string;
            simulationLink?: string;
        };
    };
};

/**
 * List of transactions with their status, signing requirements, and wallet type specific data
 */
export type WalletsV1Alpha2TransactionsResponseDto = {
    /**
     * Complete transaction response including status, signing requirements, and wallet type specific data
     */
    transactions: Array<{
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'evm-smart-wallet';
        /**
         * EVM smart wallet transaction parameters
         */
        params: {
            /**
             * Transaction data to execute
             */
            calls: Array<{
                /**
                 * The recipient address for this transaction call
                 */
                address: string;
                /**
                 * The name of the function to call
                 */
                functionName: string;
                /**
                 * The ABI for the function to call
                 */
                abi: Array<{
                    type: 'error';
                    inputs: Array<unknown>;
                    name: string;
                } | {
                    type: 'event';
                    anonymous?: boolean;
                    inputs: Array<unknown & {
                        indexed?: boolean;
                    }>;
                    name: string;
                } | ({
                    constant?: boolean;
                    gas?: number;
                    payable?: boolean;
                } & ({
                    type: 'function';
                    inputs: Array<unknown>;
                    name: string;
                    outputs: Array<unknown>;
                    stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
                } | {
                    type: 'constructor';
                    inputs: Array<unknown>;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'fallback';
                    inputs?: unknown;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'receive';
                    stateMutability: 'payable';
                }))>;
                /**
                 * The arguments to pass to the function
                 */
                args: Array<unknown>;
                /**
                 * The amount of native token to send in wei
                 */
                value?: string;
            } | {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The amount of native token to send in wei
                 */
                value: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            }>;
            /**
             * The chain on which the transaction will be executed
             */
            chain: 'base' | 'polygon' | 'optimism' | 'arbitrum' | 'mode' | 'base-sepolia' | 'polygon-amoy' | 'optimism-sepolia' | 'arbitrum-sepolia' | 'mode-sepolia' | 'story-testnet';
            /**
             * The locator for the signer who will submit this transaction
             */
            signer?: string;
        };
        /**
         * EVM smart wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            userOperation: {
                sender: string;
                nonce: string;
                callData: string;
                callGasLimit: string;
                verificationGasLimit: string;
                preVerificationGas: string;
                maxFeePerGas: string;
                maxPriorityFeePerGas: string;
                paymaster?: string;
                paymasterVerificationGasLimit?: string;
                paymasterData?: string;
                paymasterPostOpGasLimit?: string;
                signature: string;
                factory?: string;
                factoryData?: string;
            };
            userOperationHash: string;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string;
                explorerLink?: string;
                simulationLink?: string;
            };
        };
    } | {
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'solana-mpc-wallet';
        /**
         * Solana custodial wallet transaction parameters
         */
        params: {
            /**
             * Base58 encoded serialized Solana transaction
             */
            transaction: string;
            /**
             * Optional array of additional signers required for the transaction
             */
            requiredSigners?: Array<string>;
        };
        /**
         * Solana custodial wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string;
                explorerLink?: string;
                simulationLink?: string;
            };
        };
    } | {
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'evm-mpc-wallet';
        /**
         * EVM MPC wallet transaction parameters
         */
        params: {
            /**
             * The transaction call to execute
             */
            call: {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            } | {
                /**
                 * The recipient address for this transaction call
                 */
                address: string;
                /**
                 * The name of the function to call
                 */
                functionName: string;
                /**
                 * The ABI for the function to call
                 */
                abi: Array<{
                    type: 'error';
                    inputs: Array<unknown>;
                    name: string;
                } | {
                    type: 'event';
                    anonymous?: boolean;
                    inputs: Array<unknown & {
                        indexed?: boolean;
                    }>;
                    name: string;
                } | ({
                    constant?: boolean;
                    gas?: number;
                    payable?: boolean;
                } & ({
                    type: 'function';
                    inputs: Array<unknown>;
                    name: string;
                    outputs: Array<unknown>;
                    stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
                } | {
                    type: 'constructor';
                    inputs: Array<unknown>;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'fallback';
                    inputs?: unknown;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'receive';
                    stateMutability: 'payable';
                }))>;
                /**
                 * The arguments to pass to the function
                 */
                args: Array<unknown>;
            };
            /**
             * The chain on which the transaction will be executed
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'zenchain-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'lightlink' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium';
        };
        /**
         * EVM MPC wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            call: {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            };
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string;
                explorerLink?: string;
                simulationLink?: string;
            };
        };
    } | {
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'solana-smart-wallet';
        /**
         * Solana smart wallet transaction parameters
         */
        params: {
            /**
             * Base58 encoded serialized Solana transaction
             */
            transaction: string;
            /**
             * Optional array of additional signers required for the transaction
             */
            requiredSigners?: Array<string>;
            /**
             * The locator for the signer who will submit this transaction. Defaults to the admin signer.
             */
            signer?: string;
        };
        /**
         * Solana smart wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string;
                explorerLink?: string;
                simulationLink?: string;
            };
        };
    }>;
};

/**
 * Wallet error
 */
export type WalletV1Alpha2ErrorDto = {
    error: true;
    /**
     * Error message
     */
    message: string;
};

/**
 * Complete wallet configuration including type-specific settings
 */
export type WalletV1Alpha2ResponseDto = {
    /**
     * The type of wallet configuration
     */
    type: 'evm-smart-wallet';
    /**
     * EVM smart wallet type specific configuration settings
     */
    config: {
        adminSigner: {
            /**
             * Identifier for EVM keypair signer type
             */
            type: 'evm-keypair';
            /**
             * The Ethereum address of the external signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for EVM Fireblocks custodial signer type
             */
            type: 'evm-fireblocks-custodial';
            /**
             * The Ethereum address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'evm-passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        };
        /**
         * Optional array of additional signers for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * Identifier for EVM keypair signer type
             */
            type: 'evm-keypair';
            /**
             * The Ethereum address of the external signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for EVM Fireblocks custodial signer type
             */
            type: 'evm-fireblocks-custodial';
            /**
             * The Ethereum address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'evm-passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        } | {
            /**
             * Specifies the type of EVM signer being used, describing the method of key management and transaction signing. `evm-keypair` indicates a signer using a locally managed keypair, suitable for non-custodial wallets. `evm-fireblocks-custodial` refers to a signer managed by Fireblocks, a custodial service provider.
             */
            type: 'evm-keypair' | 'evm-fireblocks-custodial';
            /**
             * The Ethereum address of the signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The expiry date of the signer in ISO 8601 format
             */
            expiresAt?: number;
            /**
             * The permissions of the signer following ERC-7715
             */
            permissions?: Array<{
                type: 'native-token-transfer';
                data: {
                    allowance: string;
                };
            } | {
                type: 'erc20-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    allowance: string;
                };
            } | {
                type: 'erc721-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    /**
                     * The token IDs that can be transferred
                     */
                    tokenIds: Array<string>;
                };
            } | {
                type: 'erc1155-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    /**
                     * The token IDs and allowances that can be transferred
                     */
                    allowances: {
                        [key: string]: string;
                    };
                };
            } | {
                type: 'gas-limit';
                data: {
                    limit: string;
                    enforcePaymaster?: boolean;
                    allowedPaymaster?: string;
                };
            } | {
                type: 'call-limit';
                data: {
                    count: number;
                };
            } | {
                type: 'rate-limit';
                data: {
                    count: number;
                    /**
                     * Time window in seconds
                     */
                    interval: number;
                };
            }>;
        }>;
    };
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'solana-smart-wallet';
    /**
     * Solana Smart wallet type specific configuration settings
     */
    config: {
        adminSigner: {
            /**
             * Type identifier for Solana keypair signers
             */
            type: 'solana-keypair';
            /**
             * The Solana address of the signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Type identifier for Solana custodial signers
             */
            type: 'solana-fireblocks-custodial';
            /**
             * The Solana address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        };
    };
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'solana-mpc-wallet';
    /**
     * Solana MPC wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'aptos-mpc-wallet';
    /**
     * Aptos MPC wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'cardano-mpc-wallet';
    /**
     * Cardano MPC wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'sui-mpc-wallet';
    /**
     * Sui MPC wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'evm-mpc-wallet';
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
};

/**
 * Wallet transaction error
 */
export type WalletV1Alpha2TransactionErrorDto = {
    /**
     * Error
     */
    error: {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string;
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    /**
     * Error message
     */
    message: string;
};

/**
 * EVM
 */
export type Nftevm = Array<{
    /**
     * The blockchain used in the request.
     */
    chain?: string;
    /**
     * The token contract address
     */
    contractAddress?: string;
    /**
     * The numeric tokenId for the specified NFT
     */
    tokenId?: string;
    metadata?: {
        attributes?: Array<{
            trait_type?: string;
            value?: string;
            display_type?: string | null;
        }>;
        collection?: {
            [key: string]: unknown;
        };
        description?: string;
        /**
         * URL that represents the image for the NFT
         */
        image?: string;
        /**
         * Optional URL representing a video or other multimedia file
         */
        animation_url?: string | null;
        name?: string;
    };
    /**
     * The address of the NFT on the blockchain
     */
    locator?: string;
    /**
     * The type of contract this token is from (ERC-721, ERC-1155 or ERC-5643)
     */
    tokenStandard?: string;
    subscription?: {
        /**
         * The date and time when the subscription expires
         */
        expiresAt?: string;
    };
}>;

/**
 * Solana
 */
export type Nftsol = Array<{
    /**
     * The blockchain used in the request, `solana` in this case.
     */
    chain?: string;
    /**
     * The unique identifier of this NFT on Solana
     */
    mintHash?: string;
    metadata?: {
        name?: string;
        description?: string;
        /**
         * A URL that represents the image for the NFT
         */
        image?: string;
        attributes?: Array<{
            value?: string | number | boolean | {
                [key: string]: unknown;
            };
            trait_type?: string;
        }>;
    };
    /**
     * The address of the NFT on the blockchain
     */
    locator?: string;
}>;

export type _Error = {
    error?: string;
};

export type WalletsV1ControllerSubmitMeApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals';
};

export type WalletsV1ControllerSubmitMeApprovals4Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerSubmitMeApprovals4Error = WalletsV1ControllerSubmitMeApprovals4Errors[keyof WalletsV1ControllerSubmitMeApprovals4Errors];

export type WalletsV1ControllerSubmitMeApprovals4Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};

export type WalletsV1ControllerSubmitMeApprovals4Response = WalletsV1ControllerSubmitMeApprovals4Responses[keyof WalletsV1ControllerSubmitMeApprovals4Responses];

export type WalletsV1ControllerGetMeTransaction4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/transactions/{transactionId}';
};

export type WalletsV1ControllerGetMeTransaction4Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetMeTransaction4Error = WalletsV1ControllerGetMeTransaction4Errors[keyof WalletsV1ControllerGetMeTransaction4Errors];

export type WalletsV1ControllerGetMeTransaction4Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionResponseDto;
};

export type WalletsV1ControllerGetMeTransaction4Response = WalletsV1ControllerGetMeTransaction4Responses[keyof WalletsV1ControllerGetMeTransaction4Responses];

export type WalletsV1ControllerCreateMeTransaction4Data = {
    body: CreateTransactionDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        'x-idempotency-key': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/transactions';
};

export type WalletsV1ControllerCreateMeTransaction4Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified type is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};

export type WalletsV1ControllerCreateMeTransaction4Error = WalletsV1ControllerCreateMeTransaction4Errors[keyof WalletsV1ControllerCreateMeTransaction4Errors];

export type WalletsV1ControllerCreateMeTransaction4Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};

export type WalletsV1ControllerCreateMeTransaction4Response = WalletsV1ControllerCreateMeTransaction4Responses[keyof WalletsV1ControllerCreateMeTransaction4Responses];

export type WalletsV1ControllerSubmitMeSignatureApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals';
};

export type WalletsV1ControllerSubmitMeSignatureApprovals4Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerSubmitMeSignatureApprovals4Error = WalletsV1ControllerSubmitMeSignatureApprovals4Errors[keyof WalletsV1ControllerSubmitMeSignatureApprovals4Errors];

export type WalletsV1ControllerSubmitMeSignatureApprovals4Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};

export type WalletsV1ControllerSubmitMeSignatureApprovals4Response = WalletsV1ControllerSubmitMeSignatureApprovals4Responses[keyof WalletsV1ControllerSubmitMeSignatureApprovals4Responses];

export type WalletsV1ControllerGetMeSignature4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signatures/{signatureId}';
};

export type WalletsV1ControllerGetMeSignature4Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetMeSignature4Error = WalletsV1ControllerGetMeSignature4Errors[keyof WalletsV1ControllerGetMeSignature4Errors];

export type WalletsV1ControllerGetMeSignature4Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsV1Alpha2SignatureResponseDto;
};

export type WalletsV1ControllerGetMeSignature4Response = WalletsV1ControllerGetMeSignature4Responses[keyof WalletsV1ControllerGetMeSignature4Responses];

export type WalletsV1ControllerCreateMeSignatureRequest4Data = {
    body: CreateSignatureRequestDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate signature creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signatures';
};

export type WalletsV1ControllerCreateMeSignatureRequest4Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerCreateMeSignatureRequest4Error = WalletsV1ControllerCreateMeSignatureRequest4Errors[keyof WalletsV1ControllerCreateMeSignatureRequest4Errors];

export type WalletsV1ControllerCreateMeSignatureRequest4Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};

export type WalletsV1ControllerCreateMeSignatureRequest4Response = WalletsV1ControllerCreateMeSignatureRequest4Responses[keyof WalletsV1ControllerCreateMeSignatureRequest4Responses];

export type WalletsV1ControllerGetMeWallet4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}';
};

export type WalletsV1ControllerGetMeWallet4Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV1Alpha2ResponseDto;
};

export type WalletsV1ControllerGetMeWallet4Response = WalletsV1ControllerGetMeWallet4Responses[keyof WalletsV1ControllerGetMeWallet4Responses];

export type WalletsV1ControllerCreateMeWallet4Data = {
    body: CreateWalletDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path?: never;
    query?: never;
    url: '/2022-06-09/wallets/me';
};

export type WalletsV1ControllerCreateMeWallet4Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for this user, or creates and returns a new wallet (201).
     */
    201: WalletV1Alpha2ResponseDto;
};

export type WalletsV1ControllerCreateMeWallet4Response = WalletsV1ControllerCreateMeWallet4Responses[keyof WalletsV1ControllerCreateMeWallet4Responses];

export type WalletsV1ControllerSubmitApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals';
};

export type WalletsV1ControllerSubmitApprovals4Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerSubmitApprovals4Error = WalletsV1ControllerSubmitApprovals4Errors[keyof WalletsV1ControllerSubmitApprovals4Errors];

export type WalletsV1ControllerSubmitApprovals4Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};

export type WalletsV1ControllerSubmitApprovals4Response = WalletsV1ControllerSubmitApprovals4Responses[keyof WalletsV1ControllerSubmitApprovals4Responses];

export type WalletsV1ControllerGetTransaction4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}';
};

export type WalletsV1ControllerGetTransaction4Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetTransaction4Error = WalletsV1ControllerGetTransaction4Errors[keyof WalletsV1ControllerGetTransaction4Errors];

export type WalletsV1ControllerGetTransaction4Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionResponseDto;
};

export type WalletsV1ControllerGetTransaction4Response = WalletsV1ControllerGetTransaction4Responses[keyof WalletsV1ControllerGetTransaction4Responses];

export type WalletsV1ControllerGetTransactionsWithoutChain4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2022-06-09/wallets/{walletLocator}/transactions';
};

export type WalletsV1ControllerGetTransactionsWithoutChain4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetTransactionsWithoutChain4Error = WalletsV1ControllerGetTransactionsWithoutChain4Errors[keyof WalletsV1ControllerGetTransactionsWithoutChain4Errors];

export type WalletsV1ControllerGetTransactionsWithoutChain4Responses = {
    /**
     * The transactions have been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionsResponseDto;
};

export type WalletsV1ControllerGetTransactionsWithoutChain4Response = WalletsV1ControllerGetTransactionsWithoutChain4Responses[keyof WalletsV1ControllerGetTransactionsWithoutChain4Responses];

export type WalletsV1ControllerCreateTransaction4Data = {
    body: CreateTransactionDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/transactions';
};

export type WalletsV1ControllerCreateTransaction4Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};

export type WalletsV1ControllerCreateTransaction4Error = WalletsV1ControllerCreateTransaction4Errors[keyof WalletsV1ControllerCreateTransaction4Errors];

export type WalletsV1ControllerCreateTransaction4Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};

export type WalletsV1ControllerCreateTransaction4Response = WalletsV1ControllerCreateTransaction4Responses[keyof WalletsV1ControllerCreateTransaction4Responses];

export type WalletsV1ControllerGetDelegatedSigner4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
        /**
         * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
         */
        signer: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signers/{signer}';
};

export type WalletsV1ControllerGetDelegatedSigner4Errors = {
    /**
     * Returns an error if the wallet or signer not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetDelegatedSigner4Error = WalletsV1ControllerGetDelegatedSigner4Errors[keyof WalletsV1ControllerGetDelegatedSigner4Errors];

export type WalletsV1ControllerGetDelegatedSigner4Responses = {
    /**
     * The delegated signer has been successfully retrieved.
     */
    200: DelegatedSignerDto;
};

export type WalletsV1ControllerGetDelegatedSigner4Response = WalletsV1ControllerGetDelegatedSigner4Responses[keyof WalletsV1ControllerGetDelegatedSigner4Responses];

export type WalletsV1ControllerCreateDelegatedSigner4Data = {
    body: CreateSignerInputDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signers';
};

export type WalletsV1ControllerCreateDelegatedSigner4Errors = {
    /**
     * Returns an error if a delegated signer with specified configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerCreateDelegatedSigner4Error = WalletsV1ControllerCreateDelegatedSigner4Errors[keyof WalletsV1ControllerCreateDelegatedSigner4Errors];

export type WalletsV1ControllerCreateDelegatedSigner4Responses = {
    /**
     * The delegated signer has been successfully added to the wallet.
     */
    201: DelegatedSignerDto;
};

export type WalletsV1ControllerCreateDelegatedSigner4Response = WalletsV1ControllerCreateDelegatedSigner4Responses[keyof WalletsV1ControllerCreateDelegatedSigner4Responses];

export type WalletsV1ControllerSubmitSignatureApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals';
};

export type WalletsV1ControllerSubmitSignatureApprovals4Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerSubmitSignatureApprovals4Error = WalletsV1ControllerSubmitSignatureApprovals4Errors[keyof WalletsV1ControllerSubmitSignatureApprovals4Errors];

export type WalletsV1ControllerSubmitSignatureApprovals4Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};

export type WalletsV1ControllerSubmitSignatureApprovals4Response = WalletsV1ControllerSubmitSignatureApprovals4Responses[keyof WalletsV1ControllerSubmitSignatureApprovals4Responses];

export type WalletsV1ControllerGetSignature4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}';
};

export type WalletsV1ControllerGetSignature4Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetSignature4Error = WalletsV1ControllerGetSignature4Errors[keyof WalletsV1ControllerGetSignature4Errors];

export type WalletsV1ControllerGetSignature4Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsV1Alpha2SignatureResponseDto;
};

export type WalletsV1ControllerGetSignature4Response = WalletsV1ControllerGetSignature4Responses[keyof WalletsV1ControllerGetSignature4Responses];

export type WalletsV1ControllerGetAllSignatures4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2022-06-09/wallets/{walletLocator}/signatures';
};

export type WalletsV1ControllerGetAllSignatures4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetAllSignatures4Error = WalletsV1ControllerGetAllSignatures4Errors[keyof WalletsV1ControllerGetAllSignatures4Errors];

export type WalletsV1ControllerGetAllSignatures4Responses = {
    /**
     * The signatures have been successfully retrieved.
     */
    200: WalletsV1Alpha2MultipleSignatureResponseDto;
};

export type WalletsV1ControllerGetAllSignatures4Response = WalletsV1ControllerGetAllSignatures4Responses[keyof WalletsV1ControllerGetAllSignatures4Responses];

export type WalletsV1ControllerCreateSignatureRequest4Data = {
    body: CreateSignatureRequestDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate signature creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signatures';
};

export type WalletsV1ControllerCreateSignatureRequest4Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerCreateSignatureRequest4Error = WalletsV1ControllerCreateSignatureRequest4Errors[keyof WalletsV1ControllerCreateSignatureRequest4Errors];

export type WalletsV1ControllerCreateSignatureRequest4Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};

export type WalletsV1ControllerCreateSignatureRequest4Response = WalletsV1ControllerCreateSignatureRequest4Responses[keyof WalletsV1ControllerCreateSignatureRequest4Responses];

export type WalletsV1ControllerGetWalletByLocator4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}';
};

export type WalletsV1ControllerGetWalletByLocator4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerGetWalletByLocator4Error = WalletsV1ControllerGetWalletByLocator4Errors[keyof WalletsV1ControllerGetWalletByLocator4Errors];

export type WalletsV1ControllerGetWalletByLocator4Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV1Alpha2ResponseDto;
};

export type WalletsV1ControllerGetWalletByLocator4Response = WalletsV1ControllerGetWalletByLocator4Responses[keyof WalletsV1ControllerGetWalletByLocator4Responses];

export type WalletsV1ControllerCreateWallet4Data = {
    body: CreateWalletDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate wallet creation
         */
        'x-idempotency-key'?: string;
    };
    path?: never;
    query?: never;
    url: '/2022-06-09/wallets';
};

export type WalletsV1ControllerCreateWallet4Errors = {
    /**
     * Returns an error if a wallet with the specified creation seed and signer configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
};

export type WalletsV1ControllerCreateWallet4Error = WalletsV1ControllerCreateWallet4Errors[keyof WalletsV1ControllerCreateWallet4Errors];

export type WalletsV1ControllerCreateWallet4Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for the provided linkedUser or idempotencyKey, or creates and returns a new wallet (201). The response includes the wallet details and whether it was newly created.
     */
    201: WalletV1Alpha2ResponseDto;
};

export type WalletsV1ControllerCreateWallet4Response = WalletsV1ControllerCreateWallet4Responses[keyof WalletsV1ControllerCreateWallet4Responses];

export type FetchContentFromWalletData = {
    body?: never;
    path: {
        /**
         * The wallet identifier in the format of `<chain>:<address>`, `email:<email_address>:<chain>` or `userId:<userId>:<chain>`.
         */
        identifier: string;
    };
    query: {
        /**
         * Page index
         */
        page: string;
        /**
         * Number of items to display per page
         */
        perPage: string;
    };
    url: '/2022-06-09/wallets/{identifier}/nfts';
};

export type FetchContentFromWalletErrors = {
    /**
     * Bad request. Either the blockchain prefix is incorrect, the address does not exist, or the locator is malformed
     */
    400: _Error;
};

export type FetchContentFromWalletError = FetchContentFromWalletErrors[keyof FetchContentFromWalletErrors];

export type FetchContentFromWalletResponses = {
    /**
     * Success
     */
    200: Nftevm | Nftsol;
};

export type FetchContentFromWalletResponse = FetchContentFromWalletResponses[keyof FetchContentFromWalletResponses];

export type BalanceControllerGetBalanceForLocator2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain(s) to query. Comma-separated list of chains
         */
        chains?: string;
        /**
         * The tokens to query. Comma-separated list
         */
        tokens: string;
    };
    url: '/v1-alpha2/wallets/{walletLocator}/balances';
};

export type BalanceControllerGetBalanceForLocator2Errors = {
    /**
     * Returns an error (400) if the wallet locator is invalid or if the address type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
};

export type BalanceControllerGetBalanceForLocator2Error = BalanceControllerGetBalanceForLocator2Errors[keyof BalanceControllerGetBalanceForLocator2Errors];

export type BalanceControllerGetBalanceForLocator2Responses = {
    /**
     * Returns the balance of the wallet for the given chain and currency
     */
    200: WalletBalanceResponseDto;
};

export type BalanceControllerGetBalanceForLocator2Response = BalanceControllerGetBalanceForLocator2Responses[keyof BalanceControllerGetBalanceForLocator2Responses];

export type BalanceControllerFundWallet2Data = {
    body: FundWalletAmountDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         */
        walletLocator: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/balances';
};

export type BalanceControllerFundWallet2Errors = {
    /**
     * Returns an error (404) if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};

export type BalanceControllerFundWallet2Error = BalanceControllerFundWallet2Errors[keyof BalanceControllerFundWallet2Errors];

export type BalanceControllerFundWallet2Responses = {
    /**
     * Funds sent successfully.
     */
    201: WalletBalanceResponseDto;
};

export type BalanceControllerFundWallet2Response = BalanceControllerFundWallet2Responses[keyof BalanceControllerFundWallet2Responses];

export type ClientOptions = {
    baseUrl: 'https://staging.crossmint.com/api' | 'https://www.crossmint.com/api' | (string & {});
};